services:

  traefik:
    image: traefik:${TRAEFIK_VERSION}
    command:
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.http.address=:80
      - --entrypoints.https.address=:443
      - --entrypoints.http.http.redirections.entrypoint.to=https
      - --entrypoints.http.http.redirections.entrypoint.scheme=https
      # The auth headers get dropped even when the auth middleware is not mapped
      - --entrypoints.https.http.middlewares=drop-auth-headers@docker
      # See note at the botton on the TLS-ALPN-01 challenge
      - --certificatesresolvers.letsencrypt.acme.tlschallenge=true
      - --certificatesresolvers.letsencrypt.acme.email=${ADMIN_MAIL}
      - --certificatesresolvers.letsencrypt.acme.storage=acme.json
      # In test environments, uncomment the following line
      - --certificatesresolvers.letsencrypt.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory
    ports:
      - 80:80
      - 443:443
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro

  authelia:
    image: authelia/authelia:${AUTHELIA_VERSION}
    restart: unless-stopped
    command:
      - --config
      - /run/secrets/authelia-access-control.yml
    depends_on:
      authelia-cache:
        condition: service_started
    expose:
      - 9091
    labels:
      traefik.enable: true
      traefik.http.routers.authelia.rule: Host(`auth.${DOMAIN}`)
      traefik.http.routers.authelia.entrypoints: https
      traefik.http.routers.authelia.tls.certresolver: letsencrypt
      traefik.http.middlewares.authelia.forwardauth.address: http://authelia:9091/api/verify?rd=https://auth.${DOMAIN}/
      traefik.http.middlewares.authelia.forwardauth.trustForwardHeader: true
      traefik.http.middlewares.authelia.forwardauth.authResponseHeaders: Remote-User,Remote-Groups,Remote-Name,Remote-Email
      traefik.http.middlewares.drop-auth-headers.headers.customrequestheaders.Remote-User:
      traefik.http.middlewares.drop-auth-headers.headers.customrequestheaders.Remote-Groups:
      traefik.http.middlewares.drop-auth-headers.headers.customrequestheaders.Remote-Name:
      traefik.http.middlewares.drop-auth-headers.headers.customrequestheaders.Remote-Email:
    healthcheck:
      disable: true
    environment:
      TZ: Europe/Zurich
      # If the file does not exist, authelia outputs an error, generates the
      # file and then exits. Restarting the service then works fine.
      AUTHELIA_AUTHENTICATION_BACKEND_FILE_PATH: /config/users.yml
      AUTHELIA_JWT_SECRET_FILE: /run/secrets/authelia-jwt-secret
      AUTHELIA_NOTIFIER_SMTP_HOST: ${SMTP_HOST}
      AUTHELIA_NOTIFIER_SMTP_PASSWORD_FILE: /run/secrets/smtp-pass
      AUTHELIA_NOTIFIER_SMTP_PORT: ${SMTP_PORT}
      AUTHELIA_NOTIFIER_SMTP_SENDER: ${SYSTEM_MAIL_SENDER}
      AUTHELIA_NOTIFIER_SMTP_USERNAME: ${SMTP_USER}
      AUTHELIA_SESSION_DOMAIN: ${DOMAIN}
      AUTHELIA_SESSION_SECRET_FILE: /run/secrets/authelia-session-secret
      AUTHELIA_SESSION_REDIS_HOST: authelia-cache
      AUTHELIA_SESSION_REDIS_PORT: 6379
      AUTHELIA_STORAGE_ENCRYPTION_KEY_FILE: /run/secrets/authelia-storage-encryption-key
      AUTHELIA_STORAGE_LOCAL_PATH: /config/storage.sqlite3
    volumes:
      - authelia-config:/config
    secrets:
      - smtp-pass
      - authelia-access-control.yml
      - authelia-jwt-secret
      - authelia-session-secret
      - authelia-storage-encryption-key

  authelia-cache:
    image: redis:6.2-alpine
    restart: unless-stopped
    volumes:
      - authelia-cache:/data

  navidrome:
    image: deluan/navidrome:${NAVIDROME_VERSION}
    restart: unless-stopped
    user: 1000:1000
    depends_on:
      # Only actually needed when deploying from scratch, but what you gonna do
      user-volumes:
        condition: service_completed_successfully
    expose:
      - 4533
    labels:
      traefik.enable: true
      traefik.http.routers.navidrome.rule: Host(`music.${DOMAIN}`)
      traefik.http.routers.navidrome.entrypoints: https
      traefik.http.routers.navidrome.tls.certresolver: letsencrypt
      traefik.http.routers.navidrome.middlewares: authelia@docker
    environment:
      # All requests come through traefik, and we cannot specify a hostname only
      # an IP range, so we must trust all IPs (and it's safe in this setup).
      ND_REVERSEPROXYWHITELIST: 0.0.0.0/0
      # Listen kids, don't passwords like navidrome ðŸ™„
      ND_PASSWORDENCRYPTIONKEY: ${NAVIDROME_WTF}
    volumes:
      - navidrome-data:/data
      - /srv/music:/music:ro

  syncthing:
    build:
      context: images/stash-syncthing
      args:
        syncthing_version: ${SYNCTHING_VERSION}
    image: stash-syncthing:${SYNCTHING_VERSION}
    restart: unless-stopped
    user: 1000:1000
    depends_on:
      # If run as root, the entrypoint only sets the ownership of the HOME
      # directory, not the actual config directory below it.
      user-volumes:
        condition: service_completed_successfully
    expose:
      - 8384 # Web UI, through traefik
    labels:
      traefik.enable: true
      traefik.http.routers.navidrome.rule: Host(`syncthing.${DOMAIN}`)
      traefik.http.routers.navidrome.entrypoints: https
      traefik.http.routers.navidrome.tls.certresolver: letsencrypt
      traefik.http.routers.navidrome.middlewares: authelia@docker
    ports:
      - 22000:22000/tcp # TCP file transfers
      - 22000:22000/udp # QUIC file transfers
    environment:
      GUI_ENABLED: true
      GUI_UNPROTECTED: true # The GUI is behind authelia and hopefully it works
      INSTANCE_NAME: ${DOMAIN}
    volumes:
      - syncthing-config:/var/syncthing/config
      # TODO: Mount music share

  # Set the ownership of freshly created volumes because docker doesn't provide
  # this feature essential to non-root containers, and compose didn't find it
  # judicious to palliate that ðŸ™„
  user-volumes:
    build:
      context: images/user-volumes
    volumes:
      - navidrome-data:/mnt/navidrome-data
      - syncthing-config:/mnt/syncthing-config


volumes:
  # Authelia's config needs to be persisted because it holds important data that
  # cannot be recovered or regenerated: users' passwords (which they can change)
  # and their 2FA configurations.
  authelia-config:
  authelia-cache:
  navidrome-data:
  syncthing-config:

secrets:
  # Ideally there should be a way to define the ac rules (e.g. required roles)
  # at the service level using traefik annotations, but there doesn't seem to be
  # a way to do that currently.
  # On top of that authelia doesn't currently support defining ac rules using
  # environment variables. The only way is to have them in a configuration file
  # in the container.
  # Mounting using secrets instead of a normal bind mount makes it a bit nicer
  # on the original file on the host (e.g. no ownership change) and allows if
  # needed to specify a different ownership in the container.
  authelia-access-control.yml:
    file: secrets/authelia/access-control.yml
  authelia-jwt-secret:
    file: secrets/authelia/jwt-secret
  authelia-session-secret:
    file: secrets/authelia/session-secret
  authelia-storage-encryption-key:
    file: secrets/authelia/storage-encryption-key
  smtp-pass:
    file: secrets/smtp-pass


# NOTE ON THE ACME TLS-ALPN-01 CHALLENGE
#
# If AAAA records are present for the host, letsencrypt will use it to perform
# the challenge verification and won't try A records if the verification fails
# due to an unreachable host. Combine this with the fact that docker does not
# enable IPv6 by default, and this leads to very confusing results and unhelpful
# errors.
#
# On top of that, if IPv6 is enabled in docker and not carefully configured,
# each container can potentially get a public IPv6 address and become reachable
# on any port from the outside world. In short: IPv6 in docker does not work the
# same as IPv4, and in particular there is no NAT later protecting the
# containers.
#
# So for now, the best course of action seem to be removing the AAAA records for
# the host, handle letsencrypt certificates from outside of docker, or use
# another challenge type (HTTP-01 works well from within docker, even with AAAA
# records pointing to the host).
#
# See also:
# - https://stackoverflow.com/q/66090810
# - https://github.com/robbertkl/docker-ipv6nat
